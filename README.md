# آزمایش ششم آزمایشگاه مهندسی نرم‌افزار
- رضا عبداله‌زاده ۹۷۱۰۶۱۳۲
- نونا قاضی‌زاده ۹۸۱۷۱۰۰۷
## توضیحات آزمایش

### ریفکتور strategy
<p align="justify">  

در این بخش ما switch case داخل کلاس Address را برداشته و به جای آن یک Strategy گذاشتیم. 
با این تغییر در صورتی که در هر کدام از آن caseها بخواهد کاری انجام شود می‌شود به راحتی تنها در کلاس‌های strategy مربوطه اضافه شود.

  </p>
  
  ![](https://github.com/nonaghazizadeh/SE_lab_7/assets/59199865/1a45830c-6469-4354-92fb-cfe7fa7618e1)
  
  
### ریفکتور seperate query modifier
<p align="justify">  

در این بخش از آنجا که هم مقدار lastDateAddress تغییر میکرد و هم برگشت داده می‌شد، دو عملکرد رو در قالب دو متد جدا کردیم و رفرنس‌هاشو تغییر دادیم. 
  </p>
  
  ![](https://github.com/nonaghazizadeh/SE_lab_7/assets/59199865/d7647d76-dd70-4bbe-8515-e2b8e2c4ab9e)
  
### ریفکتور self encapsulated field

<p align="justify">
  بر اساس ریفکتور self encapsulated fields دو استفاده‌ی فیلد‌های پرایوت addressStrategy و lastTempIndex رو به صورت getter درآوردیم.
  
  </p>
  
  ![](https://github.com/nonaghazizadeh/SE_lab_7/assets/59199865/f9978b2d-daeb-451f-85a2-aa16cf3b4b7a)
  
  ### ریفکتور extract method
  <p align="justify">
  دو تکرار معنادار در کد را که مربوط به ثبت متد یک کلاس در  پارسر هست رو به صورت یک متد جدا به نام registerMethod درآوردیم که ریفکتور Extract Method محسوب می‌شود.
  
  </p>
  
  ![](https://github.com/nonaghazizadeh/SE_lab_7/assets/59199865/06953cbd-d0fa-432a-a64a-d4f59bc6b13e)
  
  
 ### ریفکتور inline temp
 <p align="justify">
  یکی از local temp variableها رو که تنها تعریف و بعد استفاده شده بود رو به صورت در خط استفاده کردیم که ریفکتور inline temp می‌باشد.
  </p>
  
  ![](https://github.com/nonaghazizadeh/SE_lab_7/assets/59199865/996ef2dc-6238-45dd-a12b-a9a4987017de)
  
  ### ریفکتور facade (مورد اول)
  <p align="justify">

  در کلاس Parser به سرویس‌های CodeGenerator و Lexical Analysis در چند موقعیت دسترسی شده بود که این‌ها رو به یک کلاس مجزای ParserFacade منتقل کردیم که برای اعمال دیزاین پترن Facade است.
  
  </p>
  
  ![](https://github.com/nonaghazizadeh/SE_lab_7/assets/59199865/1097cfe3-a88a-4f3d-8e25-dd72db742beb)
  
### ریفکتور facade (مورد دوم)
<p align="justify">

به منظور اعمال الگو facade برای کلاس main بک کلاس ParserStarterFacade تعریف می‌کنیم که از داخل main آن را صدا بزند.
  </p>
  
  ![](https://github.com/nonaghazizadeh/SE_lab_7/assets/59199865/4924a91d-af7a-4f1d-87b5-2b996d4e8613)



## پرسش‌ها
### سوال ۱
<p align="justify">
  کد تمیز به کدی می‌گویند که برنامه‌نویسان دیگر بتوانند آن را متوجه شوند یعنی خوانایی داشته باشد و از اصول توافقی و ثابت استفاده کند. همچنین دارای duplication نباشد و به طور منطقی و معقول سازمان‌دهی شده است به طوری که قسمت‌های مختلف کد به طور مناسب جدا شده‌اند. به‌علاوه اینکه به گونه‌ای باشه که در صورت نیاز به تغییرات در آینده، این تغییرات به راحتی قابل اعمال باشند یعنی maintable باشد. 
 </br>
  </br>

  بدهی فنی را می‌توان به صورت کار عجله‌ای و یا بی‌دقت توسعه‌دهنده‌ها در قسمتی از توسعه‌ی نرم‌افزار تعریف کرد که بعدا گریبان‌گیر تیم توسعه خواهد شد و آن‌ها مجبور می‌شوند که اوضاع را درست کنند. به‌ عبارت دیگر، این نتیجه اولویت دادن به تحویل سریع بر کد کامل است.
</br>
 </br>

بوی بد اصطلاحا به اشتباهاتی گفته می‌شود که بعدها باعث بروز مشکلات بزرگتر در کد می‌شوند. این اشتباهات ممکن است ناشی از طراحی نامناسب، کدنویسی ناخوانا، عدم رعایت استانداردهای برنامه‌نویسی و دیگر موارد باشند. به بیانی دیگر  نشان‌دهنده مشکلاتی هستند که در زمان بازآریایی می‌توان به آن‌ها رسید. معمولا به راحتی قابل شناسایی و تعمیر هستند اما ممکن است آن‌ها نشان‌دهنده‌ی مشکلات بزرگ‌تر و عمیق‌تری درون برنامه‌ ما باشند.
  </p>
  
### سوال ۲
<p align="justify">
  مورد اول bloaters است بدین صورت است که کدها، روش‌ها و کلاس‌هایی هستند که از نظر سایزی بزرگ و حجیم شدند و کار کردن با آن‌ها سخت است. معمولا این‌ها فورا ظاهر نمی‌شوند، بلکه در طول زمان و با تکامل برنامه جمع می‌شوند.
  </br>
   </br>

  مورد دوم object oriented abusers است بدین صورت است که همه این‌ها مربوط به کاربرد ناقص یا نادرست اصول برنامه نویسی شی گرا است.
  </br>
   </br>

  مورد سوم change preventers است بدین صورت است که در برنامه برای تغییر در یک بخش از کد باید مقدار زیادی از بخش‌های دیگر را نیز تغییر دهیم و این باعث می‌شود که نگهداری و توسعه بسیار پیچیده و هزینه‌بر شود.
  </br>
   </br>

  مورد چهارم dispensable است بدین صورت است که یک چیز بی‌معنی و غیر ضروری است که نبود آن نه تنها باعث مشکل نمی‌شود بلکه کد را پاک‌تر، کارآمدتر و درک آسان‌تر می‌کند.
  </br>
   </br>

  مورد پنجم couplers است بدین صورت است که نشان‌دهنده این است که coupling زیاد بین کلاس‌ها وجود دارد و نشان‌دهنده این است که اگر coupling را با delegation عوض کنیم چه اتفاقی می‌افتد.

  
  </p>
  
  ### سوال ۳ 
  
  <p align="justify">
  در دسته چهارم یا همان dispensable قرار می‌گیرد.
  </br>
   </br>

برای برطرف کردن این بو می‌توان از دو باز‌آرایی استفاده کرد:

<ul>
  <li>  اجزایی که تقریبا کارایی ندارند باید توسط inline-class بازآرایی شوند.
</li>
  <li>  برای زیرکلاس‌هایی با متد‌های اندک می‌توان از بازآرایی Collapse Hierarchy استفاده کرد.
</li>
</ul>  
  </p>
  <p align="justify">
  </br>
  زمانی که باید این بو را نادیده بگیرم، زمانی است که ممکن است یک Lazy Class برای ترسیم کردن اهدافمان در توسعه‌های آینده درست شده باشد. در این صورت ما باید یک توازنی بین واضح بودن و سادگی را در کدمان رعایت کنیم.
  </p>










  
  
  
  
  
  
